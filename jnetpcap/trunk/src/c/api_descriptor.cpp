/***************************************************************************
 * Copyright (C) 2010, Sly Technologies, Inc                               *
 * Distributed under the Lesser GNU Public License  (LGPL)                 *
 ***************************************************************************/

/*
 * Small parts of the file were based on C source file written
 * by Patrick Charles and Jonas Lehmann from http://sf.net/projects/jpcap 
 * project. 
 *
 * JNI wrapper around Libpcap and Winpcap. The included header signatures 
 * here were autogenerated using Java JDK supplied "javah" program. The file 
 * contains methods that do the minimum amount neccessary to adapt Libpcap
 * calls and translate them to Java. The few structures that are used by
 * C libpcap implementation have their own Java counter parts with JNI
 * implementations. The JNI implementation of those native methods simply 
 * read and write directly out of the C structures, adapting any objects
 * as neccessary for Java VM environment.
 *
 * This implementation does not utilize instance numbers to reffer to 
 * structures but maintains a structure pointer that is stored within the Java 
 * class as a long field. The implementation uses the stored long value 
 * as a structure pointer which is used to access the original strucutre.
 * As previously stated, any reads or writes using the Java API translate
 * direct reads and writes from the underlying C structure. Care must be
 * taken not to modify any structure, through Java interface, if that is
 * a private structure as returned from Libpcap itself. 
 *
 * The purpose of this type of implementation is to provide all the capabilities
 * of the underlying libpcap library, including any quirks that may 
 * entail.
 *
 * There are no exception thrown from any JNI method defined here. All 
 * error conditions are passed on into the Java environment as originally
 * discovered from libpcap. The only exception thrown is the 
 * IllegalStateException if a serious error has been discovered that prevents
 * the completion of a JNI call. Such as the "physical" address of a 
 * structure stored in Java object is null or invalid.
 * 
 * Other then that, most error codes are simply the
 * integer return value and the message has been written into the user
 * provided byte[] buffer. The strings contained in byte[] buffers need
 * be encoded and decoded using the trivial UTC8 encoding.
 * 
 */

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <pcap.h>
#include <jni.h>

#include "api_descriptor.h"
#include "jnetpcap_utils.h"
#include "nio_jmemory.h"

/**
 * Gets a api_vtable pointer from APILoader object.
 */
api_vtable *api_descriptor_jget(JNIEnv *env, jobject obj) {
	api_vtable *vtable = (api_vtable *)getJMemoryPhysical(env, obj);

	return vtable;
}

/**
 * Creates a new APILoader object peered with supplied ptr. The pointer is a
 * api_vtable structure that APILoader can use to register and manipulate
 * API calls.
 */
jobject api_descriptor_jcreate(JNIEnv *env, api_vtable *ptr) {
	jclass clazz = env->FindClass("org/jnetsoft/library/APIDescriptor");
	if (clazz == NULL) {
		return NULL;
	}
	
	jmethodID constructor_MID = env->GetMethodID(clazz, "<init>", "()V");
	if (constructor_MID == NULL) {
		return NULL;
	}

	/*
	 * Use a no-arg constructor and initialize 'physical' field using
	 * special JNI priviledges.
	 */
	jobject obj = env->NewObject(clazz, constructor_MID);
	if (obj == NULL) {
		return NULL;
	}
	
	setJMemoryPhysical(env, obj, toLong(ptr));

	return obj;
}

/*
 * Class:     org_jnetsoft_library_APIDescriptor
 * Method:    register
 * Signature: (Ljava/lang/Class;ILjava/lang/String;)I
 */
JNIEXPORT jint JNICALL Java_org_jnetsoft_library_APIDescriptor_register
  (JNIEnv *env, jobject obj, jclass newClass, jint index, jstring name) {
	
	JNINativeMethod method;
	char buf[1024];
	
	api_vtable *api = api_descriptor_jget(env, obj);
	if (api == NULL || name == NULL) {
		return -1;
	}
	
	int len = env->GetStringUTFLength(name);
	const char *utf = env->GetStringUTFChars(name, NULL);
	strncpy(buf, utf, len);
	buf[len] = '\0';
	env->ReleaseStringUTFChars(name, utf);

	method.name = buf;
	method.signature = api->vtable[index].signature;
	method.fnPtr = api->vtable[index].fnPtr;

	return env->RegisterNatives(newClass, &method, 1);
}

/*
 * Class:     org_jnetsoft_library_APIDescriptor
 * Method:    registerAll
 * Signature: (Ljava/lang/Class;)I
 */
JNIEXPORT jint JNICALL Java_org_jnetsoft_library_APIDescriptor_registerAll
(JNIEnv *env, jobject obj, jclass newClass) {
	
	api_vtable *api = api_descriptor_jget(env, obj);
	if (api == NULL) {
		return -1;
	}
	
	return env->RegisterNatives(newClass, api->vtable, api->vtable_count);
}

/*
 * Class:     org_jnetsoft_library_APIDescriptor
 * Method:    registerAllExcept
 * Signature: (Ljava/lang/Class;[I)I
 */
JNIEXPORT jint JNICALL Java_org_jnetsoft_library_APIDescriptor_registerAllExcept
(JNIEnv *env, jobject obj, jclass newClass, jintArray excludeIndexes) {
	api_vtable *api = api_descriptor_jget(env, obj);
	if (api == NULL || excludeIndexes == NULL) {
		return -1;
	}
	
	int size = env->GetArrayLength(excludeIndexes);
	jint *array = env->GetIntArrayElements(excludeIndexes, NULL);
	
	int r = 0;
	int exclude = 0;
	
	for (int i = 0; i < api->vtable_count; i ++) {
		for (int j = 0; j < size; j ++) {
			if (i == array[j]) {
				exclude = 1;
				break;
			}
		}
		
		if (exclude) {
			exclude = 0;
			continue;
		}
		
		r = env->RegisterNatives(newClass, &api->vtable[i], 1);
		if (r < 0) {
			break;
		}
	}
	
	env->ReleaseIntArrayElements(excludeIndexes, array, JNI_ABORT);
	
	return r;
}
