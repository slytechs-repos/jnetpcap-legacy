<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><title>JCL Technology Guide - Logging</title><style type="text/css" media="all">
          @import url("./style/maven-base.css");
          
          @import url("./style/maven-theme.css");@import url("./style/project.css");</style><link rel="stylesheet" href="./style/print.css" type="text/css" media="print"></link><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta><meta name="author" content="Commons Documentation Team"></meta><meta name="email" content="commons-dev@jakarta.apache.org"></meta></head><body class="composite"><div id="banner"><a href="http://jakarta.apache.org" id="organizationLogo"><img alt="The Apache Software Foundation" src="http://jakarta.apache.org/images/original-jakarta-logo.gif"></img></a><a href="http://jakarta.apache.org/commons/logging/" id="projectLogo"><img alt="Logging" src="./images/logo.png"></img></a><div class="clear"><hr></hr></div></div><div id="breadcrumbs"><div class="xleft">Last published: 09 May 2006
                <span class="separator">|</span> Doc for  1.1
                </div><div class="xright">
        
        <a href="http://jakarta.apache.org/commons/" class="externalLink" title="External Link">Jakarta Commons</a>
      </div><div class="clear"><hr></hr></div></div><div id="leftColumn"><div id="navcolumn"><div id="menuCommons_Logging_1_1"><h5>Commons Logging 1.1</h5><ul><li class="none"><a href="index.html">Overview</a></li><li class="none"><a href="guide.html">User Guide</a></li><li class="none"><strong><a href="tech.html">Tech Guide</a></strong></li><li class="none"><a href="troubleshooting.html">Troubleshooting Guide</a></li><li class="none"><a href="http://wiki.apache.org/jakarta-commons/Logging" class="externalLink" title="External Link">Wiki</a></li><li class="none"><a href="apidocs/index.html">JavaDoc</a></li><li class="none"><a href="RELEASE-NOTES.txt">Release Notes</a></li><li class="none"><a href="building.html">Building</a></li><li class="none"><a href="http://jakarta.apache.org/site/downloads/downloads_commons-logging.cgi" class="externalLink" title="External Link">Download</a></li></ul></div><div id="menu1_0_4_Release"><h5>1.0.4 Release</h5><ul><li class="none"><a href="http://jakarta.apache.org/commons/logging/commons-logging-1.0.4/docs/" class="externalLink" title="External Link">Documentation</a></li><li class="none"><a href="http://jakarta.apache.org/commons/logging/commons-logging-1.0.4/docs/apidocs/" class="externalLink" title="External Link">JavaDoc</a></li><li class="none"><a href="http://jakarta.apache.org/commons/logging/commons-logging-1.0.4/RELEASE-NOTES.txt" class="externalLink" title="External Link">Release Notes</a></li></ul></div><div id="menu1_0_3_Release"><h5>1.0.3 Release</h5><ul><li class="none"><a href="http://jakarta.apache.org/commons/logging/commons-logging-1.0.3/usersguide.html" class="externalLink" title="External Link">User Guide</a></li><li class="none"><a href="http://jakarta.apache.org/commons/logging/commons-logging-1.0.3/docs/api/" class="externalLink" title="External Link">JavaDoc</a></li><li class="none"><a href="http://jakarta.apache.org/commons/logging/commons-logging-1.0.3/RELEASE-NOTES.txt" class="externalLink" title="External Link">Release Notes</a></li></ul></div><div id="menu1_0_2_Release"><h5>1.0.2 Release</h5><ul><li class="none"><a href="http://jakarta.apache.org/commons/logging/commons-logging-1.0.2/docs/api/" class="externalLink" title="External Link">JavaDoc</a></li></ul></div><div id="menuProject_Documentation"><h5>Project Documentation</h5><ul><li class="none"><a href="index.html">About</a></li><li class="collapsed"><a href="project-info.html">Project Info</a></li><li class="collapsed"><a href="maven-reports.html">Project Reports</a></li><li class="none"><a href="http://jakarta.apache.org/commons/charter.html" class="externalLink" title="External Link">Development Process</a></li></ul></div><div id="menuCommons"><h5>Commons</h5><ul><li class="none"><a href="http://jakarta.apache.org/commons/" class="externalLink" title="External Link">Home</a></li><li class="collapsed"><a href="http://jakarta.apache.org/commons/components.html" class="externalLink" title="External Link">Components</a></li><li class="collapsed"><a href="http://jakarta.apache.org/commons/sandbox/index.html" class="externalLink" title="External Link">Sandbox</a></li><li class="collapsed"><a href="http://jakarta.apache.org/commons/dormant/index.html" class="externalLink" title="External Link">Dormant</a></li><li class="none"><a href="http://jakarta.apache.org/commons/volunteering.html" class="externalLink" title="External Link">Volunteering</a></li><li class="none"><a href="http://jakarta.apache.org/commons/patches.html" class="externalLink" title="External Link">Contributing Patches</a></li><li class="none"><a href="http://jakarta.apache.org/commons/building.html" class="externalLink" title="External Link">Building Components</a></li><li class="none"><a href="http://jakarta.apache.org/commons/releases/index.html" class="externalLink" title="External Link">Releasing Components</a></li><li class="none"><a href="http://wiki.apache.org/jakarta-commons/FrontPage" class="externalLink" title="External Link">Wiki</a></li></ul></div><div id="legend"><h5>Legend</h5><ul><li class="externalLink">External Link</li><li class="newWindow">Opens in a new window</li></ul></div><a href="http://maven.apache.org/" title="Built by Maven" id="poweredBy"><img alt="Built by Maven" src="./images/logos/maven-feather.png"></img></a></div></div><div id="bodyColumn"><div class="contentBox"><div class="section"><a name="Overview"></a><h2>Overview</h2>
  		<div class="subsection"><a name="Contents"></a><h3>Contents</h3>
  			<ul>
  				<li>
  				Overview
  					<ul>
  						<li>
  						Contents
  						</li>
  						<li>
  						<a href="#Introduction">Introduction</a>
  						</li>
  					</ul>
  				</li>
  				<li>
		  			<a href="#A_Short_Introduction_to_Class_Loading_and_Class_Loaders">
		  			A Short Introduction to Class Loading and Class Loaders
		  			</a>
		  				<ul>
							<li>
								<a href="#Preamble">
						Preamble
								</a>
							</li>
		      				<li>
		      					<a href="#Resolution_Of_Symbolic_References">
		      			Resolution Of Symbolic References
		      					</a>
		       				</li>
		    				<li>
								<a href="#Loading">
						Loading
								</a>
							</li>
							<li>
								<a href="#Linking">
						Linking
								</a>
							</li>
							<li>
								<a href="#Loading_Classes">
						Loading Classes
								</a>
							</li>
		    				<li>
		    					<a href="#Bootstrap_Classloader">
						Bootstrap Classloader
								</a>
							</li>
							<li>
								<a href="#Runtime_Package">			
						Runtime Package
								</a>
		    				</li>
							<li>
								<a href="#Loader_Used_To_Resolve_A_Symbolic_Reference">
						Loader Used To Resolve A Symbolic Reference
								</a>
							</li>
							<li>
								<a href="#Bibliography">
						Bibliography
								</a>
							</li>
					</ul>
				</li>
								<li>
									<a href="#A_Short_Guide_To_Hierarchical_Class_Loading">
					A Short Guide To Hierarchical Class Loading
									</a>
					<ul>
						<li>
							<a href="#Delegating_Class_Loaders">
					Delegating Class Loaders
							</a>
						</li>
				 		<li>
							<a href="#Parent-First_And_Child-First_Class_Loaders">
					Parent-First And Child-First Class Loaders
							</a>
						</li>
				 		<li>
							<a href="#Class_ClassLoader">
					Class ClassLoader
							</a>
						</li>
				 		<li>
							<a href="#Context_ClassLoader">
					Context ClassLoader
							</a>
						</li>
				 		<li>
							<a href="#The_Context_Classloader_in_Container_Applications">
					The Context Classloader in Container Applications
							</a>
						</li>
				 		<li>
							<a href="#Issues_with_Context_ClassLoaders">
					Issues with Context ClassLoaders
							</a>
						</li>
				 		<li>
							<a href="#Reflection_And_The_Context_ClassLoader">
					Reflection And The Context ClassLoader
							</a>
						</li>
				 		<li>
							<a href="#More_Information">
					More Information
							</a>
						</li>
					</ul>
				</li>
				<li>
					<a href="#A_Short_Theory_Guide_To_JCL">
					A Short Theory Guide To JCL
					</a>
					<ul>
						<li>
							<a href="#Isolation_And_The_Context_Class_Loader">
					Isolation And The Context Class Loader
							</a>
						</li>
						<li>
							<a href="#Log_And_LogFactory">
					Log And LogFactory
							</a>
						</li>
						<li>
							<a href="#Log_Implementations">
					Log Implementations
							</a>
						</li>
    					<li>
    						<a href="#Using_Reflection_To_Load_Log_Implementations">
    				Using Reflection To Load Log Implementations
    						</a>
    					</li>
    				</ul>
    			</li>
  			</ul>
  		</div>
	 	<div class="subsection"><a name="Introduction"></a><h3>Introduction</h3>
	 		<p>
	This guide is aimed at describing the technologies that JCL developers and expert users 
	(and users who need to become experts)
	should be familiar with. The aim is to give an understanding whilst being precise but brief. 
	Details which are not relevant for JCL have been suppressed.
	References have been included.
	 		</p>
	 		<p>
	These topics are a little difficult and it's easy for even experienced developers to make
	mistakes. We need you to help us get it right! Please submit corrections, comments, additional references
	and requests for clarification
	by either:
			</p>
			<ul>
				<li>
	posting to the <a href="http://jakarta.apache.org/site/mail.html" class="externalLink" title="External Link">jakarta commons-dev mailing list</a> or
				</li>
				<li>
	creating an issue in <a href="http://issues.apache.org/bugzilla/" class="externalLink" title="External Link">Bugzilla</a>.	
				</li>
			</ul>
			<p>
	TIA	
	 		</p>
	 	</div>

	</div><div class="section"><a name="A_Short_Introduction_to_Class_Loading_and_Class_Loaders"></a><h2>A Short Introduction to Class Loading and Class Loaders</h2>
		<div class="subsection"><a name="Preamble"></a><h3>Preamble</h3>
			<p>
	This is intended to present a guide to the process by which Java bytecode uses bytecode in other classes
	from the perspective of the language and virtual machine specifications. The focus will be on deciding
	which bytecode will be used (rather than the mechanics of the usage). It focusses on facts and terminology.
			</p>
			<p>
	The process is recursive: it is therefore difficult to pick a starting point. 
	Sun's documentation starts from the persective of the startup of a new application. 
	This guide starts from the perspective of an executing application.
			</p>
			<p>
	During this discussion, please assume that each time that <em>class</em> is mentioned, 
	the comments applied equally well to interfaces. 
			</p>
			<p>
	This document is targeted at Java 1.2 and above.
			</p>
    	</div>
       <div class="subsection"><a name="Resolution_Of_Symbolic_References"></a><h3>Resolution Of Symbolic References</h3>
			<p>
	(<a href="http://java.sun.com/docs/books/jls/second_edition/html/execution.doc.html#44524" class="externalLink" title="External Link">LangSpec 12.3.3</a>)
	The bytecode representation of a class contains symbolic names for other classes referenced. 
			</p>
			<p>
				<em>
	In practical development terms: If a class is imported (either explicitly in the list of imports at the top of 
	the source file or implicitly through a fully qualified name in the source code) it is referenced symbolically.
				</em> 
			</p>
			<p>
	(<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ConstantPool.doc.html#73492" class="externalLink" title="External Link">VMSpec 5.4.3</a>)
	Resolution of a symbolic reference occurs dynamically at runtime and is carried out by
	the Java Virtual Machine. Resolution of a symbolic reference requires loading and linking of the new class. 
			</p>
			<p>
				<em>
	Note: references are not statically resolved at compile time.			
				</em>
			</p>
    	</div>
		<div class="subsection"><a name="Loading"></a><h3>Loading</h3>
			<p>
	(<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/Concepts.doc.html#19175" class="externalLink" title="External Link">VMSpec 2.17.2</a>) 
	Loading is the name given to the process by which a binary form of a class is obtained 
	by the Java Virtual Machine. 
	Java classes are always loaded and linked dynamically by the Java Virtual Machine
	(rather than statically by the compiler).
			</p>
			<p>
				<em>
	In practical development terms:
	This means that the developer has no certain knowledge about the actual
	bytecode that will be used to execute any external call (one made outside the class). This is determined only
	at execution time and is affected by the way that the code is deployed.
				</em>
			</p>
    	</div>
		<div class="subsection"><a name="Linking"></a><h3>Linking</h3>
			<p>
	(<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/Concepts.doc.html#22574" class="externalLink" title="External Link">VMSpec 2.17.3</a>) 
	Linking is the name used for combining the 
	binary form of a class into the Java Virtual Machine. This must happen before the class can be used.
			</p>
			<p>
	(<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/Concepts.doc.html#22574" class="externalLink" title="External Link">VMSpec 2.17.3</a>)  
	Linking is composed of verification, preparation and resolution (of symbolic references).
	Flexibility is allowed over the timing of resolution. (Within limit) this may happen at any time after 
	preparation and before that reference is used.
			</p>
			<p>
				<em>
	In practical development terms: This means that different JVMs may realize that a reference cannot be
	resolved at different times during execution. Consequently, the actual behaviour cannot be precisely predicted 
	without intimate knowledge of the JVM (on which the bytecode will be executed). 
	This makes it hard to give universal guidance to users.  	
				</em>
			</p>
    	</div>

		<div class="subsection"><a name="Loading_Classes"></a><h3>Loading Classes</h3>
			<p>
	(<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/Concepts.doc.html#19175" class="externalLink" title="External Link">VMSpec 2.17.2</a>)
	The loading process is performed by a <code>ClassLoader</code>.
			</p>
			<p>
	(<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ConstantPool.doc.html#72007" class="externalLink" title="External Link">VMSpec 5.3</a>) 
	A classloader may create a class either by delegation or by defining it directly.
	The classloader that initiates loading of a class is known as the initiating loader. 
	The classloader that defines the class is known as the defining loader. 
			</p>
			<p>
				<em>
	In practical terms: understanding and appreciating this distinction is crucial when debugging issues 
	concerning classloaders.
				</em>
			</p>
    	</div>
    	
		<div class="subsection"><a name="Bootstrap_Classloader"></a><h3>Bootstrap Classloader</h3>
			<p>
	(<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ConstantPool.doc.html#72007" class="externalLink" title="External Link">VMSPEC 5.3</a>) 
	The bootstrap is the base <code>ClassLoader</code> supplied by the Java Virtual Machine.
	All others are user (also known as application) <code>ClassLoader</code> instances.
			</p>
			<p>
				<em>
	In practical development terms: The System classloader returned by <code>Classloader.getSystemClassLoader()</code>
	will be either the bootstrap classloader or a direct descendent of the bootstrap classloader.
	Only when debugging issues concerning the system classloader should there be any need to consider the detailed
	differences between the bootstrap classloader and the system classloader.
				</em>
			</p>
    	</div>
		<div class="subsection"><a name="Runtime_Package"></a><h3>Runtime Package</h3>
			<p>
	(<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ConstantPool.doc.html#72007" class="externalLink" title="External Link">VMSpec 5.3</a>) 
	At runtime, a class (or interface) is determined by its fully qualified name 
	and by the classloader that defines it. This is known as the class's runtime package. 
			</p>
			<p>
	(<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ConstantPool.doc.html#75929" class="externalLink" title="External Link">VMSpec 5.4.4</a>) 
	Only classes in the same runtime package are mutually accessible.
			</p>
			<p>
				<em>
	In practical development terms: two classes with the same symbolic name can only be used interchangably 
	if they are defined by the same classloader. A classic symptom indicative of a classloader issue is that
	two classes with the same fully qualified name are found to be incompatible during a method call. 
	This may happen when a member is expecting an interface which is (seemingly) implemented by a class
	but the class is in a different runtime package after being defined by a different classloader. This is a 
	fundamental java language security feature. 
				</em>
			</p>
    	</div>
    	
		<div class="subsection"><a name="Loader_Used_To_Resolve_A_Symbolic_Reference"></a><h3>Loader Used To Resolve A Symbolic Reference</h3>
			<p>
	(<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ConstantPool.doc.html#72007" class="externalLink" title="External Link">VMSpec 5.3</a>) 
	The classloader which defines the class (whose reference is being resolved) is the one 
	used to initiate loading of the class referred to.
			</p>
			<p>
				<em>
	In practial development terms: This is very important to bear in mind when trying to solve classloader issues. 
	A classic misunderstanding is this: suppose class A defined by classloader C has a symbolic reference to 
	class B and further that when C initiates loading of B, this is delegated to classloader D which defines B.
	Class B can now only resolve symbols that can be loaded by D, rather than all those which can be loaded by C.
	This is a classic recipe for classloader problems. 
				</em>
			</p>
    	</div>
   	
		<div class="subsection"><a name="Bibliography"></a><h3>Bibliography</h3>
			<ul>
				<li>
		<a href="http://java.sun.com/docs/books/vmspec/" class="externalLink" title="External Link">VMSpec</a> <em>The Java Virtual Machine Specification, Second Edition</em> 
				</li>
				<li>
		<a href="http://java.sun.com/docs/books/jls/" class="externalLink" title="External Link">LangSpec</a> <em>The Java Language Specification, Second Edition</em>
				</li>
			</ul>
    	</div>    	
	</div><div class="section"><a name="A_Short_Guide_To_Hierarchical_Class_Loading"></a><h2>A Short Guide To Hierarchical Class Loading</h2>
		<div class="subsection"><a name="Delegating_Class_Loaders"></a><h3>Delegating Class Loaders</h3>
			<p>
	When asked to load a class, a class loader may either define the class itself or delegate.
	The base <code>ClassLoader</code> class insists that every implementation has a parent class loader. 
	This delegation model therefore naturally forms a tree structure rooted in the bootstrap classloader.
			</p>
			<p>
	Containers (i.e. applications such as servlet engines or application servers
	that manage and provide support services for a number of "contained" applications
	that run inside of them) often use complex trees to allow isolation of different applications 
	running within the container. This is particularly true of J2EE containers. 
			</p>
		</div>

		<div class="subsection"><a name="Parent-First_And_Child-First_Class_Loaders"></a><h3>Parent-First And Child-First Class Loaders</h3>
			<p>
	When a classloader is asked to load a class, a question presents itself: should it immediately
	delegate the loading to its parent (and thus only define those classes not defined by its parent)
	or should it try to define it first itself (and only delegate to its parent those classes it does
	not itself define). Classloaders which universally adopt the first approach are termed parent-first
	and the second child-first. 
			</p>
			<p>
   <strong>Note:</strong> the term child-first (though commonly used) is misleading.	
   A better term (and one which may be encountered on the mailing list) is parent-last.
   This more accurately describes the actual process of classloading performed
   by such a classloader.		
			</p>
			<p>
	Parent-first loading has been the standard mechanism in the JDK
	class loader, at least since Java 1.2 introduced hierarchical classloaders.  
			</p>
			<p>
	Child-first classloading has the advantage of helping to improve isolation 
	between containers and the applications inside them.  If an application 
	uses a library jar that is also used by the container, but the version of
	the jar used by the two is different, child-first classloading allows the
	contained application to load its version of the jar without affecting the
	container.
			</p>
			<p>
	The ability for a servlet container to offer child-first classloading 
	is made	available, as an option, by language in the servlet spec (Section
	9.7.2) that allows a container to offer child-first loading with
	certain restrictions, such as not allowing replacement of java.* or
	javax.* classes, or the container's implementation classes.
			</p>
			<p>
	Though child-first and parent-first are not the only strategies possible, 
	they are by far the most common.
	All other strategies are rare.
	However, it is not uncommon to be faced with a mixture of parent-first and child-first
	classloaders within the same hierarchy.
			</p>
		</div>

		<div class="subsection"><a name="Class_ClassLoader"></a><h3>Class ClassLoader</h3>
			<p>
	The class loader used to define a class is available programmatically by calling 
	the <code>getClassLoader</code> method
	on the class in question. This is often known as the class classloader.
			</p>
		</div>
		
		<div class="subsection"><a name="Context_ClassLoader"></a><h3>Context ClassLoader</h3>
			<p>
	Java 1.2 introduces a mechanism which allows code to access classloaders
	which are not the class classloader or one of its parents.
	A thread may have a class loader associated with it by its creator for use
	by code running in the thread when loading resources and classes. 
	This classloader is accessed by the <code>getContextClassLoader</code> 
	method on <code>Thread</code>. It is therefore often known as the context classloader.
			</p>
			<p>
	Note that the quality and appropriateness of the context classloader depends on the
	care with which the thread's owner manages it.
			</p>
		</div>
		
		<div class="subsection"><a name="The_Context_Classloader_in_Container_Applications"></a><h3>The Context Classloader in Container Applications</h3>
			<p>
	The Javadoc for 
	<a href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Thread.html#setContextClassLoader(java.lang.ClassLoader)" class="externalLink" title="External Link">
	<code>Thread.setContextClassLoader</code></a> emphasizes the setting of the 
	context classloader as an aspect of thread creation.  However, in many 
	applications the context classloader is not fixed at thread creation but 
	rather is changed throughout the life of a thread as thread execution moves
	from one context to another.  This usage of the context classloader is 
	particularly important in container applications.	
			</p>
			<p>
	For example, in a hypothetical servlet container, a pool of threads 
	is created to handle HTTP requests.  When created these threads have their 
	context classloader set to a classloader that loads container classes.  
	After the thread is assigned to handle a request, container code parses 
	the request and then determines which of the deployed web applications 
	should handle it. Only when the container is about to call code associated 
	with a particular web application (i.e. is about to cross an "application 
	boundary") is the context classloader set to the classloader used to load 
	the web app's classes.  When the web application finishes handling the 
	request and the call returns, the context classloader is set back to the 
	container classloader.
			</p>
			<p>
	In a properly managed container, changes in the context classloader are 
	made when code execution crosses an application boundary.  When contained 
	application <code>A</code> is handling a request, the context classloader 
	should be the one used to load <code>A</code>'s resources. When application 
	<code>B</code> is handling a request, the context classloader should be 
	<code>B</code>'s.
	      </p>
			<p>
	While a contained application is handling a request, it is not 
	unusual for it to call system or library code loaded by the container.  
	For example, a contained application may wish to call a utility function 
	provided by a shared library.  This kind of call is considered to be 
	within the "application boundary", so the context classloader remains 
	the contained application's classloader.  If the system or library code 
	needs to load classes or other resources only visible to the contained 
	application's classloader, it can use the context classloader to access 
	these resources.
			</p>
			<p>
	If the context classloader is properly managed, system and library code 
	that can be accessed by multiple applications can not only use it to load 
	application-specific resources, but also can use it to detect which 
	application is making a call and thereby provided services tailored to the 
	caller.
			</p>
		</div>

		<div class="subsection"><a name="Issues_with_Context_ClassLoaders"></a><h3>Issues with Context ClassLoaders</h3>
			<p>
	In practice, context classloaders vary in quality and issues sometimes arise 
	when using them.
	The owner of the thread is responsible for setting the classloader.
	If the context classloader is not set then it will default to the system
	classloader. 
	Any container doing so will cause difficulties for any code using the context classloader.
			</p>
			<p>
	The owner is also at liberty to set the classloader as they wish.
	Containers may set the context classloader so that it is neither a child nor a parent 
	of the classloader that defines the class using that loader. 
	Again, this will cause difficulties.
			</p>
			<p>
	Introduced in <a href="http://java.sun.com/j2ee/j2ee-1_3-fr-spec.pdf" class="externalLink" title="External Link">Java J2EE 1.3</a> 
	is a requirement for vendors to appropriately set the context classloader.
	Section 6.2.4.8 (1.4 text):
			</p>

    <div class="source"><pre>
This specification requires that J2EE containers provide a per thread
context class loader for the use of system or library classes in
dynamicly loading classes provided by the application.  The EJB
specification requires that all EJB client containers provide a per
thread context class loader for dynamicly loading system value classes.
The per thread context class loader is accessed using the Thread method
getContextClassLoader.

The classes used by an application will typically be loaded by a
hierarchy of class loaders. There may be a top level application class
loader, an extension class loader, and so on, down to a system class
loader.  The top level application class loader delegates to the lower
class loaders as needed.  Classes loaded by lower class loaders, such as
portable EJB system value classes, need to be able to discover the top
level application class loader used to dynamicly load application
classes.

We require that containers provide a per thread context class loader
that can be used to load top level application classes as described
above.
</pre></div>
  
			<p>
	This specification leaves quite a lot of freedom for vendors.
	(As well as using unconventional terminology and containing the odd typo.)
	It is a difficult passage (to say the least).
			</p>		
		</div>

		<div class="subsection"><a name="Reflection_And_The_Context_ClassLoader"></a><h3>Reflection And The Context ClassLoader</h3>
			<p>
	Reflection cannot bypass restrictions imposed by the java language security model, but, by avoiding symbolic
	references, reflection can be used to load classes which could not otherwise be loaded. Another <code>ClassLoader</code>
	can be used to load a class and then reflection used to create an instance. 
			</p>
			<p>
	Recall that the runtime packaging is used to determine accessibility. 
	Reflection cannot be used to avoid basic java security. 
	Therefore, the runtime packaging becomes an issue when attempting to cast classes 
	created by reflection using other class loaders.
	When using this strategy, various modes of failure are possible 
	when common class references are defined by the different class loaders.
			</p>
			<p>
	Reflection is often used with the context classloader. In theory, this allows a class defined in
	a parent classloader to load any class that is loadable by the application.
	In practice, this only works well when the context classloader is set carefully.
			</p>
		</div>

		<div class="subsection"><a name="More_Information"></a><h3>More Information</h3>
			<ul>
				<li>
					Articles On Class Loaders And Class Loading
					<ul>
						<li>
							<a href="http://www.onjava.com/pub/a/onjava/2001/07/25/ejb.html" class="externalLink" title="External Link">
	Article on J2EE class loading
							</a>
						</li>
						<li>
							<a href="http://www.onjava.com/pub/a/onjava/2003/11/12/classloader.html" class="externalLink" title="External Link">
	Article on class loading
							</a>
						</li>
						<li>
							<a href="http://www.javaworld.com/javaworld/javaqa/2003-06/01-qa-0606-load.html" class="externalLink" title="External Link">
	Article on context class loaders
							</a>
						</li>
					</ul>
				</li>
				<li>Specific Containers
					<ul>
						<li>
							<a href="http://tomcat.apache.org/tomcat-4.1-doc/class-loader-howto.html" class="externalLink" title="External Link">
	Tomcat 4.1 ClassLoader Guide
							</a>
						</li>
						<li>
							<a href="http://tomcat.apache.org/tomcat-5.0-doc/class-loader-howto.html" class="externalLink" title="External Link">
	Tomcat 5.0 ClassLoader Guide
							</a>	
						</li>
						<li>
							<a href="http://publib.boulder.ibm.com/infocenter/wasinfo/v6r0/index.jsp?topic=/com.ibm.websphere.express.doc/info/exp/ae/trun_classload_web.html" class="externalLink" title="External Link">
	Classloading In WebSphere
							</a>
						</li>
					</ul>
				</li>
			</ul>
		</div>
	</div><div class="section"><a name="A_Short_Theory_Guide_To_JCL"></a><h2>A Short Theory Guide To JCL</h2>
		<div class="subsection"><a name="Isolation_And_The_Context_Class_Loader"></a><h3>Isolation And The Context Class Loader</h3>
			<p>
	JCL takes the view that different context class loader indicate boundaries between applications
	running in a container environment. Isolation requires that JCL honours these boundaries
	and therefore allows different isolated applications to configure their logging systems
	independently.
			</p>
    	</div>
    	<div class="subsection"><a name="Log_And_LogFactory"></a><h3>Log And LogFactory</h3>
			<p>
	Performance dictates that symbolic references to these classes are present in the calling application code
	(reflection would simply be too slow). Therefore, these classes must be loadable by the classloader
	that loads the application code.
			</p>
    	</div>
    	<div class="subsection"><a name="Log_Implementations"></a><h3>Log Implementations</h3>
			<p>
	Performance dictates that symbolic references to the logging systems are present in the implementation
	classes (again, reflection would simply be too slow). So, for an implementation to be able to function, 
	it is neccessary for the logging system to be loadable by the classloader that defines the implementing class.
			</p>
    	</div>
    	
    	<div class="subsection"><a name="Using_Reflection_To_Load_Log_Implementations"></a><h3>Using Reflection To Load Log Implementations</h3>
			<p>
	However, there is actually no reason why <code>LogFactory</code> requires symbolic references to particular <code>Log</code>
	implementations. Reflection can be used to load these from an appropriate classloader 
	without unacceptable performance degradation.
	This is the strategy adopted by JCL.
			</p>
			<p>
	JCL uses the context classloader to load the <code>Log</code> implementation. 
			</p>
    	</div>
	</div></div></div><div class="clear"><hr></hr></div><div id="footer"><div class="xright">© 2001-2006, The Apache Software Foundation</div><div class="clear"><hr></hr></div></div></body></html>
